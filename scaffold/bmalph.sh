#!/usr/bin/env bash
set -euo pipefail

# BMALPH Execution Loop
# Two-level loop: outer (phase progression), inner (Ralph-style iterations)

PROJECT_DIR="${BMALPH_PROJECT_DIR:-$(pwd)}"
BMALPH_DIR="$PROJECT_DIR/bmalph"
STATE_DIR="$BMALPH_DIR/state"
AGENTS_DIR="$BMALPH_DIR/agents"
PROMPTS_DIR="$BMALPH_DIR/prompts"
CONFIG_FILE="$BMALPH_DIR/config.json"
PROGRESS_FILE="$STATE_DIR/progress.txt"

MAX_ITERATIONS=${BMALPH_MAX_ITERATIONS:-20}
START_PHASE=${1:-1}

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[bmalph]${NC} $1"; }
log_success() { echo -e "${GREEN}[bmalph]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[bmalph]${NC} $1"; }
log_error() { echo -e "${RED}[bmalph]${NC} $1"; }

# Read config
read_config_value() {
  local key="$1"
  python3 -c "import json; print(json.load(open('$CONFIG_FILE'))['$key'])" 2>/dev/null || echo ""
}

PROJECT_NAME=$(read_config_value "name")
PROJECT_DESC=$(read_config_value "description")
SCALE_LEVEL=$(read_config_value "level")

# Phase-to-agent mapping
get_agent_file() {
  local phase=$1
  case $phase in
    1) echo "$AGENTS_DIR/analyst.md" ;;
    2) echo "$AGENTS_DIR/pm.md" ;;
    3) echo "$AGENTS_DIR/architect.md" ;;
    4) echo "$AGENTS_DIR/developer.md" ;;
  esac
}

get_phase_label() {
  local phase=$1
  case $phase in
    1) echo "Analysis" ;;
    2) echo "Planning" ;;
    3) echo "Design" ;;
    4) echo "Implementation" ;;
  esac
}

# Build the prompt for a single iteration
build_prompt() {
  local phase=$1
  local iteration=$2
  local agent_file=$(get_agent_file "$phase")
  local prompt_file="$PROMPTS_DIR/phase-${phase}-iteration.md"
  local prompt=""

  # Agent persona
  if [[ -f "$agent_file" ]]; then
    prompt+="$(cat "$agent_file")"
    prompt+=$'\n\n---\n\n'
  fi

  # Phase template with variable substitution
  if [[ -f "$prompt_file" ]]; then
    local template
    template=$(cat "$prompt_file")
    template="${template//\{\{PROJECT_NAME\}\}/$PROJECT_NAME}"
    template="${template//\{\{PROJECT_DESCRIPTION\}\}/$PROJECT_DESC}"
    template="${template//\{\{SCALE_LEVEL\}\}/$SCALE_LEVEL}"
    prompt+="$template"
    prompt+=$'\n\n---\n\n'
  fi

  # Current progress
  if [[ -f "$PROGRESS_FILE" ]]; then
    prompt+="## Progress So Far"$'\n\n'
    prompt+="$(cat "$PROGRESS_FILE")"
    prompt+=$'\n\n'
  fi

  # Iteration context
  prompt+="## Iteration Context"$'\n\n'
  prompt+="- Phase: $phase ($(get_phase_label "$phase"))"$'\n'
  prompt+="- Iteration: $iteration"$'\n'
  prompt+="- Scale Level: $SCALE_LEVEL"$'\n'

  echo "$prompt"
}

# Update state file
update_state() {
  local phase=$1
  local iteration=$2
  local status=$3

  cat > "$STATE_DIR/current-phase.json" << EOF
{
  "currentPhase": $phase,
  "iteration": $iteration,
  "status": "$status",
  "startedAt": "$(cat "$STATE_DIR/current-phase.json" 2>/dev/null | python3 -c "import json,sys; print(json.load(sys.stdin).get('startedAt','$(date -u +%Y-%m-%dT%H:%M:%S.000Z)'))" 2>/dev/null || date -u +%Y-%m-%dT%H:%M:%S.000Z)",
  "lastUpdated": "$(date -u +%Y-%m-%dT%H:%M:%S.000Z)"
}
EOF
}

# Initialize phase tasks if they don't exist
init_phase_tasks() {
  local phase=$1
  local task_file="$STATE_DIR/phase-${phase}-tasks.json"

  if [[ ! -f "$task_file" ]]; then
    case $phase in
      1)
        cat > "$task_file" << 'EOF'
[
  {"id": "1.1", "title": "Gather and document requirements", "status": "pending", "priority": 1},
  {"id": "1.2", "title": "Identify constraints and dependencies", "status": "pending", "priority": 2},
  {"id": "1.3", "title": "Assess risks and mitigations", "status": "pending", "priority": 3}
]
EOF
        ;;
      2)
        cat > "$task_file" << 'EOF'
[
  {"id": "2.1", "title": "Create Product Requirements Document", "status": "pending", "priority": 1},
  {"id": "2.2", "title": "Write user stories with acceptance criteria", "status": "pending", "priority": 2},
  {"id": "2.3", "title": "Define MVP scope and generate implementation tasks", "status": "pending", "priority": 3}
]
EOF
        ;;
      3)
        cat > "$task_file" << 'EOF'
[
  {"id": "3.1", "title": "Define technology stack and architecture", "status": "pending", "priority": 1},
  {"id": "3.2", "title": "Design data model and API contracts", "status": "pending", "priority": 2},
  {"id": "3.3", "title": "Establish coding conventions and patterns", "status": "pending", "priority": 3}
]
EOF
        ;;
      4)
        # Phase 4 tasks are generated by Phase 2, but provide defaults
        if [[ ! -f "$task_file" ]]; then
          cat > "$task_file" << 'EOF'
[
  {"id": "4.1", "title": "Set up project structure and dependencies", "status": "pending", "priority": 1},
  {"id": "4.2", "title": "Implement core functionality", "status": "pending", "priority": 2},
  {"id": "4.3", "title": "Add tests and validation", "status": "pending", "priority": 3}
]
EOF
        fi
        ;;
    esac
  fi
}

# Run quality gate
run_quality_gate() {
  local phase=$1
  local phase_dir
  case $phase in
    1) phase_dir="analysis" ;;
    2) phase_dir="planning" ;;
    3) phase_dir="design" ;;
    4) phase_dir="implementation" ;;
  esac

  log_info "Running quality gate for phase $phase..."

  local gate_prompt
  gate_prompt=$(cat "$PROMPTS_DIR/quality-gate.md")
  gate_prompt="${gate_prompt//\{\{PROJECT_NAME\}\}/$PROJECT_NAME}"
  gate_prompt="${gate_prompt//\{\{CURRENT_PHASE\}\}/$phase}"
  gate_prompt="${gate_prompt//\{\{SCALE_LEVEL\}\}/$SCALE_LEVEL}"
  gate_prompt="${gate_prompt//\{\{PHASE_DIR\}\}/$phase_dir}"

  # Inject reviewer agent
  local full_prompt
  full_prompt="$(cat "$AGENTS_DIR/reviewer.md")"$'\n\n---\n\n'"$gate_prompt"

  local output
  output=$(echo "$full_prompt" | claude --print 2>/dev/null || true)

  if echo "$output" | grep -q "<quality-gate-pass>"; then
    log_success "Quality gate PASSED for phase $phase"
    return 0
  else
    log_warn "Quality gate FAILED for phase $phase"
    echo "$output" | grep -A5 "blocker" || true
    return 1
  fi
}

# Human checkpoint
human_checkpoint() {
  local phase=$1
  local next_phase=$((phase + 1))

  echo ""
  log_success "Phase $phase ($(get_phase_label "$phase")) completed!"
  echo ""

  if [[ $next_phase -le 4 ]]; then
    log_info "Ready to transition to Phase $next_phase ($(get_phase_label "$next_phase"))"
    echo ""
    read -rp "$(echo -e "${YELLOW}Approve transition? (y/n/q): ${NC}")" answer
    case $answer in
      y|Y|yes)
        log_info "Transitioning to phase $next_phase..."
        return 0
        ;;
      q|Q|quit)
        update_state "$phase" 0 "paused"
        log_info "Paused. Run 'bmalph resume' to continue."
        exit 0
        ;;
      *)
        update_state "$phase" 0 "paused"
        log_info "Paused at phase $phase. Run 'bmalph resume' to continue."
        exit 0
        ;;
    esac
  else
    log_success "All phases complete!"
    update_state 4 0 "completed"
    exit 0
  fi
}

# ========== MAIN LOOP ==========

mkdir -p "$STATE_DIR"

# Initialize progress file
if [[ ! -f "$PROGRESS_FILE" ]]; then
  echo "# BMALPH Progress Log" > "$PROGRESS_FILE"
  echo "" >> "$PROGRESS_FILE"
  echo "Project: $PROJECT_NAME" >> "$PROGRESS_FILE"
  echo "Started: $(date -u +%Y-%m-%dT%H:%M:%S.000Z)" >> "$PROGRESS_FILE"
  echo "" >> "$PROGRESS_FILE"
fi

log_info "Starting BMALPH loop"
log_info "Project: $PROJECT_NAME (Level $SCALE_LEVEL)"
echo ""

# Outer loop: phase progression
for phase in $(seq "$START_PHASE" 4); do
  log_info "=== Phase $phase: $(get_phase_label "$phase") ==="

  init_phase_tasks "$phase"
  update_state "$phase" 0 "running"

  # Inner loop: Ralph-style iterations
  iteration=0
  while [[ $iteration -lt $MAX_ITERATIONS ]]; do
    iteration=$((iteration + 1))
    update_state "$phase" "$iteration" "running"

    log_info "Phase $phase, Iteration $iteration"

    # Build prompt
    prompt=$(build_prompt "$phase" "$iteration")

    # Spawn fresh Claude instance
    output=$(echo "$prompt" | claude --print 2>/dev/null || true)

    # Check for signals
    if echo "$output" | grep -q "<phase-complete>"; then
      log_success "Phase $phase complete (iteration $iteration)"
      break
    fi

    if echo "$output" | grep -q "<needs-human>"; then
      log_warn "Human input needed:"
      echo "$output" | sed -n '/<needs-human>/,/<\/needs-human>/p' || echo "$output" | tail -5
      update_state "$phase" "$iteration" "paused"
      read -rp "$(echo -e "${YELLOW}Continue after addressing? (y/q): ${NC}")" answer
      if [[ "$answer" == "q" ]]; then
        exit 0
      fi
      continue
    fi

    if echo "$output" | grep -q "<project-complete>"; then
      log_success "Project complete!"
      update_state 4 "$iteration" "completed"
      exit 0
    fi

    # Check if all tasks in this phase are completed
    local task_file="$STATE_DIR/phase-${phase}-tasks.json"
    if [[ -f "$task_file" ]]; then
      local pending
      pending=$(python3 -c "
import json
tasks = json.load(open('$task_file'))
print(len([t for t in tasks if t['status'] != 'completed']))
" 2>/dev/null || echo "1")

      if [[ "$pending" == "0" ]]; then
        log_success "All tasks completed for phase $phase"
        break
      fi
    fi
  done

  if [[ $iteration -ge $MAX_ITERATIONS ]]; then
    log_warn "Max iterations ($MAX_ITERATIONS) reached for phase $phase"
  fi

  # Quality gate (skip for level 0-1)
  if [[ "$SCALE_LEVEL" -ge 2 ]]; then
    run_quality_gate "$phase" || {
      log_warn "Quality gate failed. Running one more iteration to fix issues..."
      prompt=$(build_prompt "$phase" "$((iteration + 1))")
      echo "$prompt" | claude --print >/dev/null 2>&1 || true
    }
  fi

  # Human checkpoint
  human_checkpoint "$phase"
done

log_success "BMALPH loop finished!"
