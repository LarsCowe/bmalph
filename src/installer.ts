import { cp, mkdir, readFile, readdir, writeFile, access } from "fs/promises";
import { readFileSync } from "fs";
import { join, basename, dirname } from "path";
import { fileURLToPath } from "url";
import { debug } from "./utils/logger.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export function getPackageVersion(): string {
  const pkgPath = join(__dirname, "..", "package.json");
  try {
    const pkg = JSON.parse(readFileSync(pkgPath, "utf-8"));
    return pkg.version;
  } catch (err) {
    throw new Error(
      `Failed to read package.json at ${pkgPath}: ${err instanceof Error ? err.message : String(err)}`,
    );
  }
}

export interface BundledVersions {
  bmadCommit: string;
  ralphCommit: string;
}

export function getBundledVersions(): BundledVersions {
  const versionsPath = join(__dirname, "..", "bundled-versions.json");
  try {
    const versions = JSON.parse(readFileSync(versionsPath, "utf-8"));
    if (!versions || typeof versions.bmadCommit !== "string" || typeof versions.ralphCommit !== "string") {
      throw new Error("Invalid bundled-versions.json structure: missing bmadCommit or ralphCommit");
    }
    return {
      bmadCommit: versions.bmadCommit,
      ralphCommit: versions.ralphCommit,
    };
  } catch (err) {
    if (err instanceof Error && err.message.includes("Invalid bundled-versions.json")) {
      throw err;
    }
    throw new Error(
      `Failed to read bundled-versions.json at ${versionsPath}: ${err instanceof Error ? err.message : String(err)}`,
    );
  }
}

export function getBmadDir(): string {
  return join(__dirname, "..", "bmad");
}

export function getRalphDir(): string {
  return join(__dirname, "..", "ralph");
}

export function getSlashCommandsDir(): string {
  return join(__dirname, "..", "slash-commands");
}

export interface UpgradeResult {
  updatedPaths: string[];
}

export interface PreviewInstallResult {
  wouldCreate: string[];
  wouldModify: string[];
  wouldSkip: string[];
}

export interface PreviewUpgradeResult {
  wouldUpdate: string[];
}

export async function copyBundledAssets(projectDir: string): Promise<UpgradeResult> {
  const bmadDir = getBmadDir();
  const ralphDir = getRalphDir();
  const slashCommandsDir = getSlashCommandsDir();

  // Validate source directories exist
  try {
    await access(bmadDir);
  } catch {
    throw new Error(`BMAD source directory not found at ${bmadDir}. Package may be corrupted.`);
  }
  try {
    await access(ralphDir);
  } catch {
    throw new Error(`Ralph source directory not found at ${ralphDir}. Package may be corrupted.`);
  }
  try {
    await access(slashCommandsDir);
  } catch {
    throw new Error(`Slash commands directory not found at ${slashCommandsDir}. Package may be corrupted.`);
  }

  // Copy BMAD files → _bmad/
  await cp(bmadDir, join(projectDir, "_bmad"), { recursive: true });

  // Generate combined manifest from module-help.csv files
  await generateManifests(projectDir);

  // Generate _bmad/config.yaml
  const projectName = await deriveProjectName(projectDir);
  await writeFile(
    join(projectDir, "_bmad/config.yaml"),
    `# BMAD Configuration - Generated by bmalph
platform: claude-code
project_name: ${projectName}
output_folder: _bmad-output
user_name: BMad
communication_language: English
document_output_language: English
user_skill_level: intermediate
planning_artifacts: _bmad-output/planning-artifacts
implementation_artifacts: _bmad-output/implementation-artifacts
project_knowledge: docs
modules:
  - bmm
`,
  );

  // Copy Ralph templates → .ralph/
  await mkdir(join(projectDir, ".ralph"), { recursive: true });
  await cp(
    join(ralphDir, "templates/PROMPT.md"),
    join(projectDir, ".ralph/PROMPT.md"),
  );
  await cp(
    join(ralphDir, "templates/AGENT.md"),
    join(projectDir, ".ralph/@AGENT.md"),
  );
  await cp(
    join(ralphDir, "RALPH-REFERENCE.md"),
    join(projectDir, ".ralph/RALPH-REFERENCE.md"),
  );

  // Copy Ralph loop and lib → .ralph/
  // Add version marker to ralph_loop.sh
  const loopContent = await readFile(join(ralphDir, "ralph_loop.sh"), "utf-8");
  const markerLine = `# bmalph-version: ${getPackageVersion()}`;
  // Use .* to handle empty version (edge case) and EOF without newline
  const markedContent = loopContent.includes("# bmalph-version:")
    ? loopContent.replace(/# bmalph-version:.*/, markerLine)
    : loopContent.replace(/^(#!.+\r?\n)/, `$1${markerLine}\n`);
  await writeFile(join(projectDir, ".ralph/ralph_loop.sh"), markedContent);
  await cp(join(ralphDir, "lib"), join(projectDir, ".ralph/lib"), { recursive: true });

  // Copy Ralph utilities → .ralph/
  await cp(join(ralphDir, "ralph_import.sh"), join(projectDir, ".ralph/ralph_import.sh"));
  await cp(join(ralphDir, "ralph_monitor.sh"), join(projectDir, ".ralph/ralph_monitor.sh"));

  // Install all slash commands → .claude/commands/
  await mkdir(join(projectDir, ".claude/commands"), { recursive: true });
  const slashFiles = await readdir(slashCommandsDir);
  for (const file of slashFiles) {
    if (file.endsWith(".md")) {
      await cp(join(slashCommandsDir, file), join(projectDir, ".claude/commands", file));
    }
  }

  // Update .gitignore
  await updateGitignore(projectDir);

  return {
    updatedPaths: [
      "_bmad/",
      ".ralph/ralph_loop.sh",
      ".ralph/ralph_import.sh",
      ".ralph/ralph_monitor.sh",
      ".ralph/lib/",
      ".ralph/PROMPT.md",
      ".ralph/@AGENT.md",
      ".ralph/RALPH-REFERENCE.md",
      ".claude/commands/",
      ".gitignore",
    ],
  };
}

export async function installProject(projectDir: string): Promise<void> {
  // Create user directories (not overwritten by upgrade)
  await mkdir(join(projectDir, "bmalph/state"), { recursive: true });
  await mkdir(join(projectDir, ".ralph/specs"), { recursive: true });
  await mkdir(join(projectDir, ".ralph/logs"), { recursive: true });
  await mkdir(join(projectDir, ".ralph/docs/generated"), { recursive: true });

  await copyBundledAssets(projectDir);
}

async function deriveProjectName(projectDir: string): Promise<string> {
  try {
    const configPath = join(projectDir, "bmalph/config.json");
    const raw = await readFile(configPath, "utf-8");
    const config = JSON.parse(raw);
    if (config.name) return config.name;
  } catch {
    // config.json doesn't exist or is invalid — fall through
  }
  return basename(projectDir);
}

async function generateManifests(projectDir: string): Promise<void> {
  const configDir = join(projectDir, "_bmad/_config");
  await mkdir(configDir, { recursive: true });

  const coreHelpPath = join(projectDir, "_bmad/core/module-help.csv");
  const bmmHelpPath = join(projectDir, "_bmad/bmm/module-help.csv");

  // Validate CSV files exist before reading
  try {
    await access(coreHelpPath);
  } catch {
    throw new Error(`Core module-help.csv not found at ${coreHelpPath}. BMAD installation may be incomplete.`);
  }

  try {
    await access(bmmHelpPath);
  } catch {
    throw new Error(`BMM module-help.csv not found at ${bmmHelpPath}. BMAD installation may be incomplete.`);
  }

  const coreContent = await readFile(coreHelpPath, "utf-8");
  const bmmContent = await readFile(bmmHelpPath, "utf-8");

  // Extract header from core (first line) and data lines from both
  const coreLines = coreContent.trimEnd().split(/\r?\n/);
  const bmmLines = bmmContent.trimEnd().split(/\r?\n/);

  const header = coreLines[0];
  const bmmHeader = bmmLines[0];

  // Validate headers match (warn if mismatch but continue)
  if (header && bmmHeader && header !== bmmHeader) {
    // Log to stderr so it's visible even without --verbose
    console.error(`Warning: CSV header mismatch detected. BMAD modules may have incompatible formats.`);
    debug(`CSV header mismatch details - core: "${header.slice(0, 50)}...", bmm: "${bmmHeader.slice(0, 50)}..."`);
  }

  const coreData = coreLines.slice(1).filter((l) => l.trim());
  const bmmData = bmmLines.slice(1).filter((l) => l.trim());

  const combined = [header, ...coreData, ...bmmData].join("\n") + "\n";

  await writeFile(join(configDir, "task-manifest.csv"), combined);
  await writeFile(join(configDir, "workflow-manifest.csv"), combined);
  await writeFile(join(configDir, "bmad-help.csv"), combined);
}

async function updateGitignore(projectDir: string): Promise<void> {
  const gitignorePath = join(projectDir, ".gitignore");
  let existing = "";

  try {
    existing = await readFile(gitignorePath, "utf-8");
  } catch {
    // File doesn't exist, start fresh
  }

  // Split into lines for exact comparison (avoid substring matching issues)
  const existingLines = new Set(
    existing.split(/\r?\n/).map((line) => line.trim()).filter(Boolean),
  );

  const entries = [".ralph/logs/", "_bmad-output/"];
  const newEntries = entries.filter((e) => !existingLines.has(e));

  if (newEntries.length === 0) return;

  const suffix =
    existing.length > 0 && !existing.endsWith("\n")
      ? "\n" + newEntries.join("\n") + "\n"
      : newEntries.join("\n") + "\n";

  await writeFile(gitignorePath, existing + suffix);
}

export async function mergeClaudeMd(projectDir: string): Promise<void> {
  const claudeMdPath = join(projectDir, "CLAUDE.md");
  const snippet = `
## BMAD-METHOD Integration

Use \`/bmalph\` to navigate phases. Use \`/bmad-help\` to discover all commands. Use \`/bmalph-status\` for a quick overview.

### Phases

| Phase | Focus | Key Commands |
|-------|-------|-------------|
| 1. Analysis | Understand the problem | \`/create-brief\`, \`/brainstorm-project\`, \`/market-research\` |
| 2. Planning | Define the solution | \`/create-prd\`, \`/create-ux\` |
| 3. Solutioning | Design the architecture | \`/create-architecture\`, \`/create-epics-stories\`, \`/implementation-readiness\` |
| 4. Implementation | Build it | \`/sprint-planning\`, \`/create-story\`, then \`/bmalph-implement\` for Ralph |

### Workflow

1. Work through Phases 1-3 using BMAD agents and workflows (interactive, command-driven)
2. Run \`/bmalph-implement\` to transition planning artifacts into Ralph format, then start Ralph

### Management Commands

| Command | Description |
|---------|-------------|
| \`/bmalph-status\` | Show current phase, Ralph progress, version info |
| \`/bmalph-implement\` | Transition planning artifacts → prepare Ralph loop |
| \`/bmalph-upgrade\` | Update bundled assets to match current bmalph version |
| \`/bmalph-doctor\` | Check project health and report issues |
| \`/bmalph-reset\` | Reset state (soft or hard reset with confirmation) |

### Available Agents

| Command | Agent | Role |
|---------|-------|------|
| \`/analyst\` | Analyst | Research, briefs, discovery |
| \`/architect\` | Architect | Technical design, architecture |
| \`/pm\` | Product Manager | PRDs, epics, stories |
| \`/sm\` | Scrum Master | Sprint planning, status, coordination |
| \`/dev\` | Developer | Implementation, coding |
| \`/ux-designer\` | UX Designer | User experience, wireframes |
| \`/tea\` | Test Engineer | Test design, validation |
`;

  let existing = "";
  try {
    existing = await readFile(claudeMdPath, "utf-8");
  } catch {
    // File doesn't exist, that's fine
  }

  if (existing.includes("## BMAD-METHOD Integration")) {
    return; // Already merged
  }

  await writeFile(claudeMdPath, existing + snippet);
}

export async function isInitialized(projectDir: string): Promise<boolean> {
  try {
    await access(join(projectDir, "bmalph/config.json"));
    return true;
  } catch {
    return false;
  }
}

export async function previewInstall(projectDir: string): Promise<PreviewInstallResult> {
  const wouldCreate: string[] = [];
  const wouldModify: string[] = [];
  const wouldSkip: string[] = [];

  // Directories that would be created
  const dirsToCreate = [
    "bmalph/state/",
    ".ralph/specs/",
    ".ralph/logs/",
    ".ralph/docs/generated/",
    "_bmad/",
    ".claude/commands/",
  ];

  for (const dir of dirsToCreate) {
    try {
      await access(join(projectDir, dir));
      // Directory exists - would be updated
      if (dir === "_bmad/" || dir === ".claude/commands/") {
        wouldModify.push(dir);
      }
    } catch {
      wouldCreate.push(dir);
    }
  }

  // Files that would be created/modified
  const filesToCheck = [
    { path: ".ralph/PROMPT.md", isTemplate: true },
    { path: ".ralph/@AGENT.md", isTemplate: true },
    { path: ".ralph/ralph_loop.sh", isTemplate: false },
    { path: "bmalph/config.json", isTemplate: false },
  ];

  for (const file of filesToCheck) {
    try {
      await access(join(projectDir, file.path));
      if (file.isTemplate) {
        wouldModify.push(file.path);
      }
    } catch {
      wouldCreate.push(file.path);
    }
  }

  // .gitignore would be modified if it exists, created otherwise
  try {
    await access(join(projectDir, ".gitignore"));
    wouldModify.push(".gitignore");
  } catch {
    wouldCreate.push(".gitignore");
  }

  // CLAUDE.md integration check
  try {
    const claudeMd = await readFile(join(projectDir, "CLAUDE.md"), "utf-8");
    if (claudeMd.includes("## BMAD-METHOD Integration")) {
      wouldSkip.push("CLAUDE.md (already integrated)");
    } else {
      wouldModify.push("CLAUDE.md");
    }
  } catch {
    wouldCreate.push("CLAUDE.md");
  }

  return { wouldCreate, wouldModify, wouldSkip };
}

export async function previewUpgrade(_projectDir: string): Promise<PreviewUpgradeResult> {
  // In upgrade, we update the bundled assets
  const wouldUpdate = [
    "_bmad/",
    ".ralph/ralph_loop.sh",
    ".ralph/ralph_import.sh",
    ".ralph/ralph_monitor.sh",
    ".ralph/lib/",
    ".ralph/PROMPT.md",
    ".ralph/@AGENT.md",
    ".ralph/RALPH-REFERENCE.md",
    ".claude/commands/",
    ".gitignore",
  ];

  return { wouldUpdate };
}
